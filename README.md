# Cpp Project Maker
A simple python library to automate C++ building process. Intended to be simple and used as an alternative to Make, cmake, sln and others.

## Building a C/C++ Project isn't supposed to be hard... **but it is!**
Unfortunatelly, not everyone find it easy to use Makefile, Cmake and the other build tools. I myself gave up on learning those, it may be just me... but I decided to create a simpler tool to build C/C++ projects. It is probably not as feature complete or versatile as the alternatives... but it gets the job done and most importantly: **You can use it without being a *Command Line / Tool / Programmer* expect.** Nice!

*(Feel free to read the [Frequently Asked Questions](#Frequently-Asked-Questions))*

## Discord
If you liked what you're seeing,
[join our Server here!](https://bit.ly/discord-uniday-us) You'll be welcomed!

## Summary:
- [Introduction](#building-a-cc-project-isnt-supposed-to-be-hard-but-it-is)
    - [Summary](#summary)
- [How to use It](#how-to-use-it)
    - [Extra Tips](#extra-usage-tips)
- [Features and Goals](#features)
- [Frequently Asked Questions](#frequently-asked-questions)
- [How does it Work *(for Nerds)*](#how-does-it-work)

-----------------------

# How to use It
**Maker is a python library**, meaning that you can just paste the `maker.py` into your C/C++ project's root directory, create a new Python file to run your compilation (like `build.py`, up to you) and import `maker` to get started.

You'll need to instantiate the `maker.Maker()` class, adjust its settings to match your project's layout and call the `build()` method!

**Here is the (code) step by step:** First you import the Maker:
```py
from maker import Maker
```
Then you instantiate it:
```py
maker = Maker()
```
And start adjusting your settings:
```py
# This is the output file name:
maker.output = "Test.out"

# You can pass compiler and/or linker flags here:
maker.compilerFlags += ["pthread"]
maker.linkerFlags   += ["ssl", "crypto"]

# Here is where your source code is located:
maker.sourceDirs  += ["Source"]

# And here is where your include directories are:
maker.includeDirs += ["Source", "ThirdParty/Include"]
```
Once you're done with the settings, you can ask it to build the project:
```py
maker.build()
```
**Piece of cake, isn't it?** :)

It also have some other useful methods to clear or rebuild the solution. If you're curious or have no idea what that means, **clear** will delete the files and folders created by the make procedure (**including the executable**, so keep that in mind). It's good if you messed something up. **Rebuild** literally just performs a clear command followed by a build one.
```py
# Clear it...
maker.clear()

# Or do a full rebuild!
maker.rebuild()
```

## Extra Usage Tips:
Check the `example.py` example if you want even more information on how to use it. But here is some extra tips:
- **`Maker` will create a folder named `Bin/` into your project**. If you're using **git**, it may be a good idea to add it to gitignore.
- **The intermediate files** generated by the compiler will be stored at `Bin/Intermediates/`. If you don't know what does that means, don't worry. You probably will not need to worry about that at all.
- **The final compiled file will be a `Bin/Build`**. Unless you got a compilation error, of course. :)
- You can change the `Bin/` directory (or name) by changing this variable:
```py
# Just don't forget to put a '/' in the end!
maker.binDir = "Some/Other/Path/"
```
- And talking about changing things... you can even change the C++ version by doing this:
```py
# The default version is set to 17!
maker.cppVersion = 20
```

# Features and Goals
The entire point of `Maker` is:
- Be **SIMPLE** to use.
- Be **CAPABLE** of compiling more advanced projects.

In a nutshell, I'd like to make this library become **the easiest thing do use even when building the hardest project**. That's it.

And I also really don't want to ask the user (a.k.a YOU) to read a complicated manual or memorize a bunch of commands in order to operate this lib. Save your time to learn more about the stuff you like and improve your project. :)

Since people love bullet points, here is a few cool ones:

- **Multithreaded by Default:** If you have a bunch of source files, it will spawn a bunch of threads (up to a limit, probably 8) to compile them. **Nice!**
- **It will find all the Files, recursively!** Yes, forget about wildcards or your nightmares with **nested directories**. If you put something inside one of your Source folders, `Maker` will find it... and compile it... and link it! **Double Nice!**
- **It will only recompile the necessary files.** If you have a huge project with a bunch of files, `Maker` will be smart and only recompile the files that does need to be recompiled. Meaning: the file(s) itself that you changed or the files that have the changed ones as a dependency. And it will figure this out for you, don't worry.
- **Forget about the command line commands and arguments!** Some people like it. I don't. And if you're just like me, you can smile now. `Maker` will not ask you to use complicated argument passing like `-lstuff -Idk --what idk=//s` and those things. It will use python and that's it.
- **Forget about complicated Recipes.** Just lioke the previous feature, you'll not be asked to write your own make recipes here. It will do it for you. So no worries!

-----------------------------

# Frequently Asked Questions
## But why not just use Command line?
Some people may find hard to understand why I've made a "simple" tool to compile my stuff, since I could just do a simple command line thing like this:
```sh
 g++ main.cpp -o program.out
```
Well, that works... but then you start having compiler flags, external libraries to link, additional include directories, nested folders with source codes in it... and most importantly: **a lot of code that don't need to be rebuilt everytime...**

This approach works for small stuff, but it gets out of control very fast. Imagine that you're making a game with lots of features and different files. You don't want to recompile every single one of them every time you change a dot in the code. It takes time... patience... and your precious seconds (or minutes) of life. So you need a system to only recompile what changes and then link everything together.

## Why not just use Visual Studio?
I do. But sometimes you'll want to program stuff for other platforms (such as Linux) and visual studio won't really help. At least not from what I was ablet o see.

## So why not just use Make?
It is just too complicated. I know people may disagree, but I myself find it extremely hard to understand and code. It's fine to create a simple "`all:`" makefile, maybe with some variables substitutions. But I was never able to get past this point. 

But most importantly: I believe that every single user wants to do one thing with make: well... Make (Build) their projects... so why not have an unified way of doing it, completely eliminating the need of a custom recipe? I believe there is a lot of room to improve on this topic, so I'll make my contribution to help those who don't understand make, just like me. :)

## What about Cmake?
Same as the make reply.

----------------------------

# How does it Work

If you want to know how I've made it (or even contribute), well, just check the `maker.py` source code... it's like 200 LOC and fairly straight forward. But here is an introduction:

- It will **use your inputs to internally generate gcc/g++ commands** (it should work with other compilers that uses the same parameters, but I haven't tested it). 
- It first generates all the `.o` files using gcc/g++, then it links them all together.
- To support recursive subdirectories, all I had to do is name the intermediate (.o) files with the absolute file path, but replacing the `/` with an underline. 

Regarding the "smart" file recompilation, a.k.a only recompile what changed:
- There is a file at `Bin/Intermediates/maker.info` that stores all the considered files and last modification dates (when considered/compiled). The file is just a python dict. 
- I use the `maker.info` file to decide if I need to recompile a specific file.
- But that's not the only thing: If I only check a given `.cpp` to see if the user changed it, it will completely ignore the fact that this file may have dependencies and those dependencies may have been changes. Hopefully `gcc/g++` have a cool parameter called `-MM`, that will list all the file dependencies. So I check them as well.

And here is an extra:
- It took me about **4:30 hours** to write this down, including this readme and make some tests. That's important, because it's a working and efficient solution to my project building problems **AND** I've been trying to learn Make since 2015 (when I started university) with no success. Sometimes the [NIH](https://en.wikipedia.org/wiki/Not_invented_here) syndrome pays off. :P